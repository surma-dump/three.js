<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js vr - ball shooter</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, user-scalable=no"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			vr - ball shooter
		</div>

		<script src="js/vr/HelioWebXRPolyfill.js"></script>
		<script src="js/comlink.js"></script>

		<script type="module">
			import * as THREE from "../build/three.module.js";

			import { BoxLineGeometry } from "./jsm/geometries/BoxLineGeometry.js";
			import { VRButton } from "./jsm/webxr/VRButton.js";

			var camera, scene, renderer;
			var controller1, controller2;

			var room;

			// Field of View
			var fov = 120;
			// Number of balls;
			var ballCount = 2000;
			// Radius of one ball
			var radius = 0.08;
			// Size of the room
			var roomSize = 6;
			// Loss of velocity when bouncing of walls
			var dampening = 0.8;

			var normal = new THREE.Vector3();
			var relativeVelocity = new THREE.Vector3();
			var count = 0;

			var clock = new THREE.Clock();
			var worker = new Worker("./webxr_vr_ballshooter/worker.js");
			var BallShooter = Comlink.wrap(worker);
			var ballShooter;
			var positions;

			init().then(() => animate());

			async function init() {
				ballShooter = await new BallShooter({
					numBalls: ballCount,
					roomSize,
					radius,
					dampening
				});
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x505050);

				camera = new THREE.PerspectiveCamera(
					fov,
					window.innerWidth / window.innerHeight,
					0.1,
					10
				);
				camera.position.set(0, 1.6, 3);

				room = new THREE.LineSegments(
					new BoxLineGeometry(roomSize, roomSize, roomSize, 10, 10, 10),
					new THREE.LineBasicMaterial({ color: 0x808080 })
				);
				room.geometry.translate(0, roomSize / 2, 0);
				scene.add(room);

				var light = new THREE.HemisphereLight(0xffffff, 0x444444);
				light.position.set(1, 1, 1);
				scene.add(light);

				var geometry = new THREE.IcosahedronBufferGeometry(radius, 2);

				for (var i = 0; i < ballCount; i++) {
					var object = new THREE.Mesh(
						geometry,
						new THREE.MeshLambertMaterial({
							color: Math.random() * 0xffffff
						})
					);
					room.add(object);
				}

				positions = await ballShooter.getPositions();
				updateBallPositions();
				await ballShooter.setCallback(
					Comlink.proxy(buffer => {
						var oldBuffer = positions;
						positions = buffer;
						ballShooter.put(Comlink.transfer(oldBuffer, [oldBuffer]));
					})
				);

				//

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.xr.enabled = true;
				document.body.appendChild(renderer.domElement);

				//

				document.body.appendChild(VRButton.createButton(renderer));

				// controllers

				function onSelectStart() {
					this.userData.isSelecting = true;
				}

				function onSelectEnd() {
					this.userData.isSelecting = false;
				}

				controller1 = renderer.xr.getController(0);
				controller1.addEventListener("selectstart", onSelectStart);
				controller1.addEventListener("selectend", onSelectEnd);
				controller1.addEventListener("connected", function(event) {
					this.add(buildController(event.data));
				});
				controller1.addEventListener("disconnected", function() {
					this.remove(this.children[0]);
				});
				scene.add(controller1);

				controller2 = renderer.xr.getController(1);
				controller2.addEventListener("selectstart", onSelectStart);
				controller2.addEventListener("selectend", onSelectEnd);
				controller2.addEventListener("connected", function(event) {
					this.add(buildController(event.data));
				});
				controller2.addEventListener("disconnected", function() {
					this.remove(this.children[0]);
				});
				scene.add(controller2);

				//

				window.addEventListener("resize", onWindowResize, false);
			}

			function buildController(data) {
				switch (data.targetRayMode) {
					case "tracked-pointer":
						var geometry = new THREE.BufferGeometry();
						geometry.setAttribute(
							"position",
							new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3)
						);
						geometry.setAttribute(
							"color",
							new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3)
						);

						var material = new THREE.LineBasicMaterial({
							vertexColors: true,
							blending: THREE.AdditiveBlending
						});

						return new THREE.Line(geometry, material);

					case "gaze":
						var geometry = new THREE.RingBufferGeometry(
							0.02,
							0.04,
							32
						).translate(0, 0, -1);
						var material = new THREE.MeshBasicMaterial({
							opacity: 0.5,
							transparent: true
						});
						return new THREE.Mesh(geometry, material);
				}
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function handleController(controller) {
				if (controller.userData.isSelecting) {
					var object = room.children[count++];

					object.position.copy(controller.position);
					object.userData.velocity.x = random(-1.5, 1.5);
					object.userData.velocity.y = random(-1.5, 1.5);
					object.userData.velocity.z = random(-9, -8);
					object.userData.velocity.applyQuaternion(controller.quaternion);

					if (count === room.children.length) count = 0;
				}
			}

			async function updateBallPositions() {
				// console.log(positions)
				var positionsB = new Float32Array(positions);
				for (var i = 0; i < room.children.length; i++) {
					var object = room.children[i];
					object.position.x = positionsB[i * 3 + 0];
					object.position.y = positionsB[i * 3 + 1];
					object.position.z = positionsB[i * 3 + 2];
				}
			}
			//

			function animate() {
				renderer.setAnimationLoop(render);
				ballShooter.start();
			}

			async function render() {
				handleController(controller1);
				handleController(controller2);

				updateBallPositions();
				//
				renderer.render(scene, camera);
			}

			function random(a, b) {
				return Math.random() * (b - a) + a;
			}
		</script>
	</body>
</html>
